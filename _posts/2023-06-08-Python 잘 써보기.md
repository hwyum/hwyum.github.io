---
title: "Python 잘 써보기"
date: 2023-06-08
tags: 
    - Python 
categories: 
    - Python
toc: true
toc_sticky: true
toc_label: "페이지 목차"
---

본 내용은 도서 <윤성우의 열혈 파이썬 중급편> 을 보면서 기록한 내용입니다. 



# 1. Immutable & Mutable

* Immutable 객체: 객체가 지닌 값의 수정이 불가능한 객체

  * 대표적인 예로 문자열과 튜플이 immutable 함. 

* Mutable 객체: 객체가 지닌 값의 수정이 가능한 객체

  * 대표적인 예로, 리스트와 딕셔너리가 mutable 함.

  

동일한 함수더라도, mutable 객체와, immutable 객체를 받는지 여부에 따라 결과가 달라질 수 있음으로 주의해야 한다. 

아래와 같은 예를 살펴보자. 

```python
def add_last(m, n):
	m += n  # m에 n의 내용을 추가
```

위 함 수에 두 개의 리스트를 인자로 전달하게 되면, 목적에 맞게 잘 동작함. 

```python
>>> r = [1,2]
>>> add_last(r, [3,4])
>>> r
[1, 2, 3, 4]
```

그런데 튜플 두 개를 인자로 전달하게 되면 기대하던 결과를 얻지 못한다. 함수 내에서 진행한 += 연산 과정에서, 그 결과에 해당하는 '새로운 튜플'이 만들어졌을 뿐 원본에 값이 추가된 것은 아니기 때문이다. 

```python
>>> t = (1,3)
>>> add_last(t, (5,7))
>>> t # 튜플에 5와 7이 추가되지 않았다. 
(1, 3)
```

튜플에 값을 추가하기 위한 함수는 아래와 같이 만들어야 한다. 

```python
def add_tuple(t1, t2):
  t1 += t2 # 새로운 튜플이 t1에 저장됨
  return t1 # 새로운 튜플을 반환

>>> tp = (1,3)
>>> tp = add_tuple(tp, (5,7))
>>> tp
(1,3,5,7)
```

반면 리스트를 다룰 때에는 'mutable' 한 객체이기 때문에, 함수 안에서 원본 데이터를 수정하게 될 수 있으니 이 점을 주의해야 한다. 아래 예시의 함수는 리스트를 전달 받아서 min, max를 출력하는 함수인데, 연산 중에 원본의 저장 순서를 변경하게 된다. 이러한 상황을 원치 않으면, 함수 내에서 리스트를 복사한 다음에 정렬을 진행해야 한다. 

```python
>>> def min_max(d):
  		d.sort() # 리스트를 오름차순으로 정렬 -> 이 과정에서 원본 데이터가 변경됨.
		  print(d[0], d[-1], sep=', ') # 맨 앞의 값과 마지막 값을 출력함
  
>>> l = [3,1,5,4]
>>> min_max(l)
1, 5
>>> l
[1,3,4,5]
```

# 2. 깊은 복사와 얕은 복사

## 2-1. 두 객체의 비교와 복사

* 객체를 비교할 때 사용할 수 있는 두 가지 연산자
  * `v1 == v2`: 변수 v1과 v2가 참조하는 **객체의** **내용이 같은가**? 
  * `v1 is v2`: 변수 v1과 v2가 참조하는 **객체는 동일 객체인가**?

* **파이썬이 복사를 진행하는 기본 방식은 "얕은 복사"**

  * immutable 객체는 '얕은 복사' 를 해도 문제가 없지만, mutable객체는 '얕은 복사'를 할 경우 문제가 될 수 있다. 그 안에 담긴 값을 수정할 수 있기 때문이다. 

  * 아래 코드에서 r2는 r1과 같은 객체를 참조하는 형태가 된다.

    ```python
    r1 = ['John', ('man', 'USA'), [175, 23]]
    r2 = list(r1) 
    ```



# 3. 리스트 컴프리헨션

## 3-1. 기본 구조

```python
>>> r1 = [1,2,3,4,5]
>>> r2 = [x*2 for x in r1 if x%2]    
>>> r2
[2,6,10]
```



## 3-2. 리스트 컴프리헨션에 for 한번 더 들어가는 경우

* 리스트 컴프리헨션에서 두 개의 for 루프가 존재 = 중첩된 for 루프와 같이 동작함. 

```python
>>> r1 = ['Black', 'White']
>>> r2 = ['Red', 'Blue', 'Green']
>>> r3 = [t + p for t in r1 for p in r2] # 중첩된 for 루프 형태의 리스트 컴프리헨션
>>> r3
['BlackRed', 'BlackBlue', 'WhiteRed', 'WhiteBlue', 'WhiteGreen']
```



### 3-2-1. 이중 for 루프에 조건 필터 추가

* 이중 for 루프 기반의 리스트 컴프리헨션에도 if절을 추가할 수 있다. 

```python
>>> r = [n*m for n in range(2,10), for m in range(1, 10) if (n*m) %2]
>>> r
[3,9,15,21,27,5,15,25,35,45,7,21,35,49,63,9,27,45,63,81]
```



# 5. Iterable 객체와 Iterator 객체

* Iterator 객체: 값을 하나씩 꺼낼 수 있도록 함. 

```python
>>> ds = [1,2,3,4]
>>> ir = iter(ds) # iterator 객체를 얻는 방법
>>> next(ir)
1
>>> next(ir)
2
>>> next(ir)
3
>>> next(ir)
4
```

* iter함수는 리스트 ds에 접근하는 도구인 'iterator' 객체를 생성하여 반환함. 
* Next 함수에 iterator 객체를 전달하면, 첫 번째 값부터 마지막까지 순차적으로 반환하게 됨. 
  * 마지막 값을 얻었음에도 불구하고 다시 next 함수를 호출하면 StopIteration 예외가 발생함.

## 5-1. Iterable 객체와 Iterator 객체의 구분











